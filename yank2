#!/bin/sh

# =============================================================================
# yank: A versatile clipboard utility for Unix-like systems
#
# Usage: yank [FILE...]
#
# Description:
#   Copies the contents of the specified files or standard input (if no files
#   are provided) to the system clipboard using multiple methods depending on
#   the environment:
#
#     - OSC 52 escape sequence (for terminal clipboard)
#     - tmux clipboard buffer (if running inside tmux)
#     - X11 clipboard utilities (xclip, xsel)
#     - Wayland clipboard utility (wl-copy)
#
# Requirements:
#   - base64
#   - xclip, xsel, or wl-copy (optional, for system clipboard)
#   - tmux (optional, for tmux clipboard)
#
# Notes:
#   - Ensure that OSC 52 is supported and enabled in your terminal emulator.
#   - If using tmux, enable passthrough by adding the following to your
#     ~/.tmux.conf:
#         set -g allow-passthrough on
#
# Author:
#   [Your Name]
# =============================================================================

# Exit immediately if a command exits with a non-zero status
set -e

# -----------------------------------------------------------------------------
# Helper Functions
# -----------------------------------------------------------------------------

# Function: known
# Description:
#   Checks if a command exists in the system's PATH.
# Usage:
#   known <command>
known() {
    command -v "$1" >/dev/null 2>&1
}

# Function: usage
# Description:
#   Displays usage information and exits.
usage() {
    echo "Usage: yank [FILE...]" >&2
    echo "Copies the contents of the given files (or stdin, if no files are given) to the system clipboard." >&2
    exit 1
}

# Function: copy_osc52
# Description:
#   Copies input data to the terminal clipboard using the OSC 52 escape sequence.
# Arguments:
#   $1 - Path to the input file.
copy_osc52() {
    maxlen=74994  # Maximum bytes for OSC 52 after base64 encoding

    # Read and encode the first maxlen bytes
    data=$(head -c "$maxlen" "$1" | base64 | tr -d '\r\n')
    esc="\033]52;c;${data}\a"

    # Adjust escape sequence for tmux or screen sessions
    if [ -n "$TMUX" ]; then
        # Check if passthrough is enabled in tmux
        if tmux show-option -gqv allow-passthrough | grep -q 'on'; then
            esc="\033Ptmux;\033${esc}\033\\"
        else
            echo "tmux 'allow-passthrough' is not enabled." >&2
            return 1
        fi
    elif [ -n "$STY" ]; then
        # Adjust for GNU Screen sessions
        esc="\033P\033${esc}\033\\"
    fi

    # Send the escape sequence to the terminal
    printf "%b" "$esc"
}

# Function: copy_tmux
# Description:
#   Copies input data to tmux's clipboard buffer.
# Arguments:
#   $1 - Path to the input file.
copy_tmux() {
    if [ -n "$TMUX" ] && known tmux; then
        tmux load-buffer - < "$1"
    fi
}

# Function: copy_to_clipboard
# Description:
#   Copies input data to the system clipboard using available clipboard utilities.
# Arguments:
#   $1 - Path to the input file.
copy_to_clipboard() {
    if known wl-copy; then
        wl-copy < "$1"
    elif known xclip; then
        xclip -selection clipboard < "$1"
    elif known xsel; then
        xsel --clipboard --input < "$1"
    elif [ "$(uname)" = "Darwin" ] && known pbcopy; then
        pbcopy < "$1"
    else
        echo "No clipboard utility found (wl-copy, xclip, xsel, pbcopy)." >&2
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Main Execution
# -----------------------------------------------------------------------------

# Display usage if no arguments are provided and no data is piped
if [ "$#" -eq 0 ] && [ -t 0 ]; then
    usage
fi

# Create a temporary file to store input data
tmpfile=$(mktemp) || {
    echo "Failed to create temporary file." >&2
    exit 1
}

# Ensure the temporary file is deleted upon script exit
trap 'rm -f "$tmpfile"' EXIT

# Read input from files or stdin into the temporary file
if [ "$#" -gt 0 ]; then
    cat "$@" > "$tmpfile"
else
    cat > "$tmpfile"
fi

# Calculate the total number of bytes in the input
len=$(wc -c < "$tmpfile")
maxlen=74994

# Warn the user if input exceeds the OSC 52 limit
if [ "$len" -gt "$maxlen" ]; then
    echo "Warning: Input is $(( len - maxlen )) bytes too long. It will be truncated for OSC 52 copy." >&2
fi

# Initialize a status variable to track copy success
status=0

# Attempt to copy via OSC 52
if ! copy_osc52 "$tmpfile"; then
    echo "OSC 52 copy failed." >&2
    status=1
fi

# Attempt to copy to tmux buffer
if ! copy_tmux "$tmpfile"; then
    echo "tmux buffer copy failed." >&2
    status=1
fi

# Attempt to copy to system clipboard
if ! copy_to_clipboard "$tmpfile"; then
    echo "System clipboard copy failed." >&2
    status=1
fi

# Exit with the appropriate status code
exit $status